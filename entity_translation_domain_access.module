<?php

/**
 * @file
 *  Resticts entity translation based on user assigned domains.
 */

/**
 * Implements hook_permission().
 */
function entity_translation_domain_access_permission() {
  return array(
    'bypass entity translation domain access' => array(
      'title' => t('Bypass entity translation domain access'),
    ),
  );
}

/**
 * Implements hook_entity_info_alter().
 */
function entity_translation_domain_access_entity_info_alter(&$info) {
  if (!empty($info['node']['translation']['entity_translation'])) {
    $info['node']['translation']['entity_translation']['class'] = 'ETDAEntityTranslationNodeHandler';
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function entity_translation_domain_access_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'menu_alter') {
    // Alter menu after the entity_translation does this.
    $group = $implementations['entity_translation_domain_access'];
    unset($implementations['entity_translation_domain_access']);
    $implementations['entity_translation_domain_access'] = $group;
  }
  if ($hook == 'node_delete') {
    // Operate first on node deletion.
    $group = $implementations['entity_translation_domain_access'];
    unset($implementations['entity_translation_domain_access']);
    $implementations = array('entity_translation_domain_access' => $group) + $implementations;
  }
}

/**
 * Implements hook_menu().
 */
function entity_translation_domain_access_menu() {
  $items = array();
  $items['admin/structure/domain/view/%domain/entity-translation'] = array(
    'title' => 'Entity translation languages',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_translation_domain_access_admin_form', 4),
    'access arguments' => array('administer domains'),
    'file' => 'entity_translation_domain_access.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function entity_translation_domain_access_menu_alter(&$items) {

  // Alter entity translation paths.
  foreach (entity_get_info() as $entity_type => $info) {
    if (entity_translation_enabled($entity_type)) {
      foreach ($info['translation']['entity_translation']['path schemes'] as $path_scheme) {

        // Replace menu access callbacks with our ones.
        $path_to_op_map = array();
        if (isset($path_scheme['edit path'])) {
          $path_to_op_map += array(
            $path_scheme['edit path'] . '/add/%entity_translation_language/%entity_translation_language' => 'add',
            $path_scheme['edit path'] . '/%entity_translation_language' => 'edit',
          );
        }
        if (isset($path_scheme['translate path'])) {
          $path_to_op_map += array(
            $path_scheme['translate path'] . '/delete/%entity_translation_language' => 'delete',
          );
        }
        foreach ($path_to_op_map as $path => $op) {
          if (isset($items[$path])) {
            array_unshift($items[$path]['access arguments'], $op);
            array_unshift($items[$path]['access arguments'], $items[$path]['access callback']);
            $items[$path]['access callback'] = 'entity_translation_domain_access_menu_access_callback';
            if ($op == 'delete') {
              $items[$path]['access arguments'][] = count(explode('/', $path)) - 1;
            }
          }
        }

        // The edit path (ex.: node/%node/edit) if a special one. We do not
        // replace the access callback, but do replace the page callback.
        /* @see entity_translation_domain_access_edit_page() */
        if (isset($items[$path_scheme['edit path']]['page callback']) && $items[$path_scheme['edit path']]['page callback'] == 'entity_translation_edit_page') {
          $items[$path_scheme['edit path']]['page callback'] = 'entity_translation_domain_access_edit_page';
        }
      }
    }
  }

}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function entity_translation_domain_access_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Use the same check as entity_translation_menu_local_tasks_alter().
  $handler = entity_translation_get_handler();
  if (!empty($handler) && $handler->isEntityForm() && $handler->getLanguage() != LANGUAGE_NONE && drupal_multilingual()) {
    // Remove translations inaccessible for a user.
    if (!empty($data['tabs'][1]['output'])) {
      foreach ($data['tabs'][1]['output'] as $key => $link) {
        // Double check that we have the correct link.
        if (isset($link['#link']['access_callback']) && $link['#link']['access_callback'] == 'entity_translation_edit_access') {
          $args = menu_unserialize($link['#link']['access_arguments'], $link['#link']['map']);
          $path_parts = explode('/', $link['#link']['href']);
          $entity_type = $args[0];
          $entity = $args[1];
          $translation_langcode = array_pop($path_parts);
          if (!EntityTranslationDomainAccess::checkTranslationAccess($entity_type, $entity, $translation_langcode, 'edit')) {
            unset($data['tabs'][1]['output'][$key]);
          }
        }
      }
      $data['tabs'][1]['output'] = array_values($data['tabs'][1]['output']);
      $data['tabs'][1]['count'] = count($data['tabs'][1]['output']);
    }
  }
}

/**
 * Implements hook_node_access();
 */
function entity_translation_domain_access_node_access($node, $op, $account) {
  if ($op == 'delete') {
    if (!EntityTranslationDomainAccess::checkNodeActionAccess($node, $op)) {
      return NODE_ACCESS_DENY;
    }
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Menu callback for entity translation pages.
 */
function entity_translation_domain_access_menu_access_callback() {
  $args = func_get_args();
  $original_callback = array_shift($args);
  $op = array_shift($args);
  $entity_type = $args[0];
  $entity = @$args[1];
  switch ($op) {
    case 'add':
      $translation_langcode = $args[3];
      break;
    case 'edit':
      $translation_langcode = $args[2];
      break;
    case 'delete':
      $translation_langcode = array_pop($args);
      if ($original_callback == 'entity_translation_node_tab_access') {
        $entity_type = 'node';
        $entity = $args[0];
      }
      break;
    default:
      return FALSE;
  }
  if (!EntityTranslationDomainAccess::checkTranslationAccess($entity_type, $entity, $translation_langcode, $op)) {
    return FALSE;
  }
  return call_user_func_array($original_callback, $args);
}

/**
 * Entity edit callback that *sometimes* replaces the original one.
 *
 * For the normal edit paths (the ones without the /%entity_translation_language
 * suffix, for example: node/%node/edit) we do not replace the access callback
 * to prevent missing tabs. For instance:
 *   - user is on the en/node/1/edit/fr path
 *   - user has access to the fr translation
 *   - user has no access to the en translation
 *   - the en/node/1/edit path uses the content_language as a current
 *     translation, so it's en in this case
 *   - the menu system checks access of the node/%node/edit path
 *   - if it's FALSE, no primary/secondary will be displayed
 * That's why we should not replace the access callback for the normal edit
 * paths. Instead, we use this function as a replacement for the
 * entity_translation_edit_page(). If a user does not have access to the
 * translation, this function searches for a translation user have access to,
 * and uses $handler->setFormLanguage() to set it as the current translation
 * language.
 *
 * @see entity_translation_edit_page()
 */
function entity_translation_domain_access_edit_page() {

  // The following was copied from the entity_translation_edit_page().
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);
  $edit_form_item = array_shift($args);
  $handler = entity_translation_get_handler($entity_type, $entity);
  $handler->initPathScheme();
  $langcode = entity_translation_get_existing_language($entity_type, $entity, $langcode);
  $handler->setFormLanguage($langcode);

  // Here is the custom code goes.
  if (!EntityTranslationDomainAccess::checkTranslationAccess($entity_type, $entity, $langcode, 'edit')) {
    $translation_langcodes = array_keys($handler->getTranslations()->data);
    while (!empty($translation_langcodes)) {
      $translation_langcode = array_shift($translation_langcodes);
      if (EntityTranslationDomainAccess::checkTranslationAccess($entity_type, $entity, $translation_langcode, 'edit')) {
        $handler->setFormLanguage($translation_langcode);
        return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
      }
    }
    drupal_set_message(t('There are no existing translations you have access to.'), 'error');
    return MENU_ACCESS_DENIED;
  }

  return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function entity_translation_domain_access_form_node_form_alter(&$form, &$form_state) {
  $node = $form['#node'];

  if (!empty($node->status) && !EntityTranslationDomainAccess::checkNodeActionAccess($node, 'unpublish')) {
    $form['options']['status']['#disabled'] = TRUE;
  }

  // Prevent user to change the "Send to all affiliates" option if he/she is
  // not assigned to all domains.
  if (isset($form['domain']['domain_site'])) {
    if (!user_access('bypass entity translation domain access') && array_diff(array_keys(domain_domains()), EntityTranslationDomainAccess::getUserDomains())) {
      $form['domain']['domain_site']['#disabled'] = TRUE;
    }
  }
  // Prevent user to assign/unassign node domains he/she is not assigned to.
  // This is just a cosmetic change and it is not applied if the "domains" form
  // element is a "select". The real work happens on node save.
  /* @see entity_translation_domain_access_node_presave() */
  if (isset($form['domain']['domains'])) {
    if ($form['domain']['domains']['#type'] == 'checkboxes' && !user_access('bypass entity translation domain access') && array_diff($form['domain']['domains']['#options'], EntityTranslationDomainAccess::getUserDomains())) {
      $form['domain']['domains']['#after_build'][] = 'entity_translation_domain_access_node_domains_after_build';
    }
  }
}

/**
 * After build handler for the "domains" checkboxes.
 *
 * @see entity_translation_domain_access_form_node_form_alter()
 * @see entity_translation_domain_access_node_presave()
 */
function entity_translation_domain_access_node_domains_after_build($element, &$form_state) {
  foreach (element_children($element) as $key) {
    if (!in_array($element[$key]['#return_value'], EntityTranslationDomainAccess::getUserDomains())) {
      $element[$key]['#attributes']['disabled'] = 'disabled';
      $element[$key . '_value'] = array(
        '#type' => 'hidden',
        '#name' => $element[$key]['#name'],
        '#value' => $element[$key]['#return_value'],
      );
      $element[$key]['#name'] = '';
    }
  }
  return $element;
}

/**
 * Implements hook_node_presave().
 */
function entity_translation_domain_access_node_presave($node) {
  if (!drupal_is_cli() && !empty($node->original->status) && empty($node->status) && !EntityTranslationDomainAccess::checkNodeActionAccess($node, 'unpublish')) {
    // The reason to prevent unpublishing in hook_node_presave() is that there
    // are too many places from where the unpublishing could be performed:
    //   - node edit form
    //   - VBO
    //   - standard admin/content (uses node_mass_update() which does not check
    //     permission at all)
    //   - node_unpublish_action()
    // In most of these cases, we alter the access, so we actually should never
    // reach this line.
    $node->status = NODE_PUBLISHED;
    drupal_set_message(t('The content %title has not been unpublished because either it assigned to domains that you are not assigned to, or it has translations you do not have access to.', array('%title' => entity_label('node', $node))), 'error');
    watchdog('entity_translation_domain_access', 'Prevented node unpublish attempt. Node: !node, user: !user', array(
      '!node' => l(entity_label('node', $node), 'node/' . $node->nid),
      '!user' => l(entity_label('user', $GLOBALS['user']), 'user/' . $GLOBALS['user']->uid),
    ), WATCHDOG_WARNING);
  }

  // Prevent user to assign/unassign node domains he/she is not assigned to.
  if (!user_access('bypass entity translation domain access')) {
    $user_domains = EntityTranslationDomainAccess::getUserDomains();
    foreach (domain_domains() as $domain_id => $_) {
      if (!in_array($domain_id, $user_domains)) {
        $node->domains[$domain_id] = isset($node->original->domains[$domain_id]) ? $node->original->domains[$domain_id] : 0;
      }
    }
  }
}

/**
 * Implements hook_ctools_plugin_post_alter().
 */
function entity_translation_domain_access_ctools_plugin_post_alter(&$plugin, &$info) {
  if ($info['module'] == 'views_bulk_operations' && $info['type'] == 'operation_types' && $plugin['name'] == 'action') {
    // We actually need to replace the class. But if we just replace it, it
    // won't be processed by the ctools_registry_files_alter(), so our class
    // will not be created because it will extend non existing class.
    // So, we do the trick:
    // 1. Register file of original class manually.
    // 2. Leave $plugin['handler']['file'] unchanged, so Ctools still knows
    //    where the plugin lives.
    // 3. Add relative path to $plugin['handler']['file'].
    $registry_files_alter =& drupal_static('entity_translation_domain_access_registry_files_alter', array());
    $registry_files_alter[$plugin['path'] . '/' . $plugin['handler']['file']] = array(
      'module' => 'views_bulk_operations',
      'weight' => 0,
    );
    $relative_path = entity_translation_domain_access_get_relative_path($plugin['path'], drupal_get_path('module', 'entity_translation_domain_access') . '/includes');
    $plugin['handler']['file'] = $relative_path . '/EntityTranslationDomainAccessViewsBulkOperationsAction.inc';
    $plugin['handler']['class'] = 'EntityTranslationDomainAccessViewsBulkOperationsAction';
  }
}

/**
 * Implements hook_registry_files_alter().
 */
function entity_translation_domain_access_registry_files_alter(&$files, $indexed_modules) {
  $registry_files_alter =& drupal_static(__FUNCTION__, array());
  foreach ($registry_files_alter as $path => $info) {
    $files[$path] = $info;
  }
}

/**
   * Returns a relative path between $start_dir and $final_dir.
   *
   * @link http://php.net/manual/en/function.realpath.php#76453
   *
   * @param string $start_dir
   * @param string $final_dir
   *
   * @return string
   */
function entity_translation_domain_access_get_relative_path($start_dir, $final_dir){
  $first_path_parts = explode('/', $start_dir);
  $second_path_parts = explode('/', $final_dir);
  $same_counter = 0;
  for ($i = 0; $i < min(count($first_path_parts), count($second_path_parts)); $i++) {
    if (strtolower($first_path_parts[$i]) !== strtolower($second_path_parts[$i])) {
      break;
    }
    $same_counter++;
  }
  if ($same_counter == 0) {
    return $final_dir;
  }
  $new_path = '';
  for ($i = $same_counter; $i < count($first_path_parts); $i++) {
    if ($i > $same_counter) {
      $new_path .= '/';
    }
    $new_path .= '..';
  }
  if (count($new_path) == 0) {
    $new_path = '.';
  }
  for ($i = $same_counter; $i < count($second_path_parts); $i++) {
    $new_path .= '/';
    $new_path .= $second_path_parts[$i];
  }
  return $new_path;
}
